React-15: (vs previous versions v0.14, v0.3)
--------------------------------


ABOUT REACT IN GENERAL:
What is React ? it's a javascript abstraction of the DOM. it adds layers to the native event system
native markup, native DOM API, therefore creating a unified interface and a change detection mechanism
between the native DOM and your javascript world. 

React wrapps the native Event system with its own Event system called React Event System with actors
like 'EventPlugins', 'SynthenticEvent' etc . . doing event normalization across browsers and environments
and also making the native event system easy to deal with inside React internal API.

it's smallest building block is a component. A React application is nothing but a tree of functions
that communicate through state and props. each of these functions has its own representation of the DOM,
it's own UI, and so it's called a React Component because it is not only a function that receives props,state
and communicate with props state, but it is also a UI unit. 

Reacy component lifecycle includes being born as a function (constructor), being mounted, being updated, and
eventually being unmounted from the DOM. React public API reveals some lifecycle methods for the React user.

The most popular usage of React is using JSX which is a transformer from <Componet props/> syntax to 
component(props) syntax.

React 'change detection mechanism' and constant reconciliation (dom update) process is based on checking if 
the markup of a component is different than the real DOM markup after any change in props, state
which is related to the component.

React patterns, or 'opinion' is to be immutable and change state only in immutable manners.

--------------------------
React v15 vs v0.3, 0.14:
--------------------------
from the official changeLog:
         document.createElement is in and data-reactid is out
         No more extra <span>s
         React.cloneElement() now resolves defaultProps
         Function components can now return null too

         Deprecated APIs are removed from the React top-level export:
         findDOMNode, render, renderToString, renderToStaticMarkup, and unmountComponentAtNode.
         As a reminder, they are now available on ReactDOM and ReactDOMServer.
         Deprecated addons are removed: batchedUpdates and cloneWithProps.
         Deprecated component instance methods are removed: setProps, replaceProps, and getDOMNode.
         React-specific properties on DOM refs (e.g. this.refs.div.props) were deprecated,
         and are removed now
my observations:

1. $$typeof: Symbol(react.element) is now holding the id of a React component

2. data-reactroot is used (as opposed to ReactRootId[] in v0.3, v0.14)


3. the updater in a React component in v15 has the following fields:
      enqueueCallback: ƒ (publicInstance, callback, callerName)
      enqueueCallbackInternal: ƒ (internalInstance, callback)
      enqueueElementInternal: ƒ (internalInstance, newElement)
      enqueueForceUpdate: ƒ (publicInstance)
      enqueueReplaceState: ƒ (publicInstance, completeState)
      enqueueSetState: ƒ (publicInstance, partialState)
      isMounted: ƒ (publicInstance)
      validateCallback: ƒ (callback, callerName)
      __proto__: Object

4. all the AccumulateDispatch methods survived v15 (existed from v0.3)

0. this.updater inside ReactClass is the same as in v0.14. this.updater is the object inside ReactClass
   which stores methods like enqueueSetState and replaceState

1. module system resolver: recognize the module system used by the React user.
   commonJS? AMD? otherwise just put React on the global object
2. sub modules resolver function that manages the entire inner 'require' of internals modules inside
   the React library. it is very ugly and bad designed.. it is a good decision by the React team to abandon
   this attitude.
3. until line 700, I see no interesting/important code to research, but only React internal Event system
   meaningless names

4. in line 900, CallbackQueue is defined (with Pooledclass) just like ReactOnDOMReady in version 0.3, 0.14
   this module is responsible for handling callbacks like componentDidMount/DidUpdate to run after component's
   markup has been injected to the DOM. the queue itself is a list of React components ready to be notified
   after their DOM has been injected. callbackQueue holds _callbacks and _contexts. and for example
   notifyAll will call each callback with the matching context. (callback.call(context))
5. reading through lines 1200+ it seems like React overall suffers from tightling coupling of different units
   such as the React Event system and the DOM utils and the React API (or namings), etc  . . .
   the way React is written is not modular. the way the reader reads the code is very not clear,
   too much complexity, and too much chaos. not clear which are the basic units and which are the bigger/higher
   units of engineering.
6. module 28: React policies still exist apparently (as in v0.3 and v.14) except for additions:
   DEFINE_MANY_MERGED,
   ReactClassInterface I believe is the new ReactCompositeComponentInterface
   bindAutoBindMethod also still exists.

7. ReactClass is a the module to create composite components in v15

8. shouldUpdateReactComponent: in v15 React offers its own implementations while in previous versions
   it only relied on the user's shouldUpdateReactComponent

NOTES:
    key code snippets:
    ReactDOMComponentTree.getNodeFromInstance,
    ReactDOMComponentTree.getClosestInstanceFromNode,
    DOMLazyTree,
    createNodesFromMarkup,
    dangerouslyRenderMarkup,
    EventPropagators,
    EventPluginRegistry,
    EventPluginUtils,
    ReactEventEmitterMixin,
    ReactEventListener,
    ReactChildren,
    ReactComponent,
    ReactClass,
    ReactElement,
    createElement,
    ReactReconciler,
    ReactInstrumentation




          /**
           * Internal store for event listeners
           */
          var listenerBank = {};

          /**
           * Internal queue of events that have accumulated their dispatches and are
           * waiting to have their dispatches executed.
           */
          var eventQueue = null;
                    /**
           * - `ComponentTree`: [required] Module that can convert between React instances
           *   and actual node references.
           */
           /**
           * Standard/simple iteration through an event's collected dispatches.
           */
          function executeDispatchesInOrder




NOTES: even in versions 0.14, 0.3, and in 15, still it all feels like a magic.
How exactly React works internally ?









NOTES:
    The DOM CompositionEvent represents events that occur due to the user indirectly entering text.









TESTS:
----------
    1
----------
a simple <button onClick={() => console.log('click')}></button>
yields the following sequence of method invocations:
 1. before any event click is triggered, when React launches, trapBubbledEvent() is called
    and it is putting 'click' event listener on document
    and dispatchEvent is the handler for this click event
    When React sees 'onClick' on a virtual DOM element, its EventPluginHub is delegating the handling to:
    SimpleEventPlugin, putting a listener on the element. 

2. the user clicks on the Hello World button and trigger the following sequence:

  ---> Calling dispatchEvent (because the click event, before all, belongs to the document tartet,
                              and dispatchEvent is the listener for this target)
  ---> Calling batchedUpdates() which triggers Transaction.perform(ReactEventListener.handleTopLevelImpl)
  ---> Calling perform 
  ---> Calling initializeAll 
  ---> Calling getEventTarget -> SEE EXPLANATIONS BENEATH
 nativeEvent: MouseEvent {isTrusted: true, screenX: 1986, screenY: 83, clientX: 66, clientY: 11, …}
  ---> Calling getEventTarget 
 nativeEvent: MouseEvent {isTrusted: true, screenX: 1986, screenY: 83, clientX: 66, clientY: 11, …}
  ---> Calling ReactEventEmitterMixin.handleTopLevel 
  ---> Calling EventPluginHub.extractEvents 
  ---> Calling SimpleEventPlugin.extractEvents 
  ---> Calling SyntheticEvent 
  ---> Calling listenerAtPhase 
  ---> Calling EventPluginHub.getListener 
  ---> Calling listenerAtPhase 
  ---> Calling EventPluginHub.getListener 
  ---> Calling EnterLeaveEventPlugin.extractEvents 
  ---> Calling ChangeEventPlugin.extractEvents 
  ---> Calling SelectEventPlugin.extractEvents 
  ---> Calling BeforeInputEventPlugin.extractEvents 
  ---> Calling extractCompositionEvent 
  ---> Calling EventPluginHub.enqueueEvents 
  ---> Calling EventPluginHub.processEventQueue 
  ---> Calling executeDispatchesInOrder 
  ---> Calling executeDispatch 
 event: Proxy {dispatchConfig: {…}, _targetInst: ReactDOMComponent, isDefaultPrevented: ƒ, isPropagationStopped: ƒ, _dispatchListeners: ƒ, …}
clicked

summary:
   1.getEventTarget = indentifying which native event was fired
   1.1 handleTopLevel = identifying the native event as 'topClick'
   2.extractEvents = the appropriate EventPluginHub which is SimpleEventPlugin is 
     'extracting' the native 'click' event, which is basically building a new object from native event
     this new object is the React Event that has the native event as one of its fields as well as
     some extra fields, logic\data. React Event is called SyntheticEvent,
     in this case: SynthecticMouseEvent
   3. EventPluginHub.getListener = identifying which React Component is the target of the event fire
   4. calling 'extractEvents' of all other plugins in the DefaultEventPlugin list (in order)
      ---> Calling EnterLeaveEventPlugin.extractEvents 
      ---> Calling ChangeEventPlugin.extractEvents 
      ---> Calling SelectEventPlugin.extractEvents 
      ---> Calling BeforeInputEventPlugin.extractEvents
   5. EventPluginHub.enqueueEvents
   6. EventPluginHub.processEventQueue
   7. ExecuteDispatchesInOrder = executes all the components onClick handlers (they are the event listeners)
      dispatchListeners is the onClick handlers, and dispatchInstances are the component themselves.
   8. executeDispatch -> in this case () => console.log('click')


SO: 
onclick -> onClick -> EventPlugin -> SimpleEventPlugi -> wrapping onclick with ReactSyntheticEvent -> fire events and triggering listeners 

   NOTE: as we can see transaction.perform which triggers initializeAll and closeAll, happens not only
         whenever the component state is updated and there is a reconciliation of the React DOM to the real DOM
         (and then the callbacks such as componentDidMount, DidUpdate are called once the component is DOM injected)
         but a transaction.perform is called after every event fired.


----------
    2
----------
React.createClass({ render: function() { return <button onClick={() => console.log('click');> </button> }})

what this code is causing React to do ?
1. user calls: React.createClass(spec)
2. ReactClass.createClass(spec) which does:
         bindAutoBindMethods(),
         getInitialState(),
         new ReactClassComponent(),
         mixSpecIntoComponent(Constructor, spec);
         and retuning an object that looks like that:
            Constructor {props: undefined, context: undefined, refs: {…}, updater: {…}, state: null}
               context: undefined
               props: undefined
               refs:
               __proto__: Object
               state: null
               updater:
               enqueueCallback: ƒ (publicInstance, callback)
               enqueueForceUpdate: ƒ (publicInstance)
               enqueueReplaceState: ƒ (publicInstance, completeState)
               enqueueSetState: ƒ (publicInstance, partialState)
               isMounted: ƒ (publicInstance)
               __proto__: Object
               __proto__: ReactClassComponent
               childContextTypes: null
               componentDidMount: null
               componentDidUpdate: null
               componentWillMount: null
               componentWillReceiveProps: null
               componentWillUnmount: null
               componentWillUpdate: null
               constructor: ƒ (props, context, updater)
               contextTypes: null
               getChildContext: null
               getDefaultProps: null
               getInitialState: null
               mixins: null
               propTypes: null
               render: ƒ ()
               shouldComponentUpdate: null
               statics: null
               updateComponent: null
               __reactAutoBindPairs: []
               __proto__: Object
3. NOTE: new Button() is different than new Component().
   apparently React.CreateElement patches it with: 
   $$typeof: Symbol(react.element) as well as hiding this.updater from it
   Apparently <Button /> is going through some phases like React.createElement which further manipulates it:
      ---> Calling ReactElementValidator.getDeclarationErrorAddendum 
      ---> Calling ReactElement.createElement 
      ---> Calling ReactElementValidator.validatePropTypes 
4.
---> Calling ReactClass.mixSpecIntoComponent 
---> Calling ReactElement.isValidElement 
---> Calling ReactClass.validateMethodOverride 
---> Calling ReactClass.RESERVED_SPEC_KEYS.displayName 
---> Calling ReactClass.validateMethodOverride


NOTES:
   React.createClass() is a terrible API, not only for the outsider( aka the React user), but internally 
   from within the React project, it is a terrible API.



-------------
---- 3 ------
-------------
simple component with a button an onMouseMove inside:
1-ReactEventListener.dispatchEvent() which is the callback registered early on when the component
  first mounted to the DOM (ReactMount does it), when React scanned the props properties inside the component
  instance: the onMouseMove prop was found inside registrationNameModules and therefore recognized as a native browser event.
  aka recognized a onMouseMove as a registeration name of a React Event, storing the listening callback in the listenerBank
  and also making sure 'dispatchEvent()' is fired as well when the event triggered.
  into the dispatchEvent list of event dispatches to notify when the event fires.
  the registering of the listener to this event happens with the help of dispatchEvent that wrapps the listening:
  so inside trapbubbledEvent() which is a terrible name, there is the setup of this listening mechanism:
  from trapBubbledEvent: returning EventListener.listen(
                element,
                handlerBaseName,
                ReactEventListener.dispatchEvent.bind(null, topLevelType)
              );
 and so the dispatchEvent listener actually has this code inside it:
 var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType,nativeEvent)
 ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
 but the event listener itself is put with enqueuePutListener which puts the listener
 inside the listenerBank and so when the event triggers, its listeners actually stored in the listenerBank
 so whenever the onMouseMove event triggered the listener is doing:
  getting the top level 'listener' that is stored in the pool
  and calling batchedUpdates on this listener.

  so inside enqueuePutListener:
              listenTo(registrationName, doc);

            transaction.getReactMountReady().enqueue(putListener, {
              inst: inst,
              registrationName: registrationName,
              listener: listener,
            });
  listenTo does the eventDispatch wrapping, and putListener() does the actuall listening to the event when
  triggered.


  in this case topLevelType: topMouseMove, nativeEvent: MouseEvent
2-ReactUpdates.ReactUpdatesFlushTransaction.batchedUpdates() which calls: transaction.perform(handleTopLevel)
  which calls ReactEventListener.handleTopLevelImpl ignoring for a second the transaction wrappers that
  wrap handleTopLevelImpl().
  so transaction.perform(handleTopLevel) ->
      ReactEventListener.handleTopLevelImpl() ->
            ReactEventListener._handleTopLevel()
3-ReactDOMComponentTree.getClosestInstanceFromNode() is searching for the React component that 
  is closest to the DOM element target of the onMouseMove event that was triggered.
  ReactEventListener._handleTopLevel() last parameter was the native event (onMouseMove) that triggered.
4-EventPluginHub calling 'extractEvent' of each event plugin.
  SimpleEventPlugin recognizing the current topLevelType of the event is onMouseMove which is 
  recognized as: SyntheticMouseEvent (then calling its constructor).
5-EventPropagators.accumulateTwoPhaseDispatches()
6-ReactDOMTreeTraversal.traverseTwoPhase
7-BeforeInputEventPlugin.getCompositionEventType() returning the accumulated events:
  which is only one SyntheticMouseEvent
8-runEventQueueInBatch() which does:EventPluginHub.enqueueEvents(events), EventPluginHub.processEventQueue(false);
9-finally run the listeners: executeDispatchesAndReleaseTopLevel()
10-EventPluginUtils.executeDispatchesInOrder()
11-releasing the resources: SyntheticEvent.destructor() etc..
12-PooledClass.standardReleaser() -> instance.destructor(); -> topLevelCallbackBookKeeping is the instance


IDEAS FOR IMPROVEMENT:
   - functions like transaction, or accumulate*, or PooledClass arguments, all built in a way that they can
     accept limited number of arguments. those functions are not written in a flexible, maintainable wanner. 
   - the entire architecture (interfaces, inheritence, etc) is terrible and much too verbose
   - remove all terrible accumulateDispatch methods and create one setupEventListeners method that does everything
   - I like ReactDefaultInjection purpose as the main 'dependency injection' system but I dislike its verbosity.
   - renaming: listen -> listenDuringBubble, capure -> listenDuringCapture
   - DOMProperty.DOMPropertyInjection.propertyInfo.checkMask must be much more explicit and self explanatory
     it is not clear whatoever.
   - names in this library are terrible. ReactCompositeComponentWrapper is a terrible name choice
   - too many different Components. ReactDOMComponent / ReactComponent / ReactCompositeComponent, 
     React functional Component, React Stateless Component / ---> have only one Component -> call it Component
   - more terrible names: mapIntoWithKeyPrefixInternal, bindAutoBindMethod
   - transaction.perform -> too verbose and shapeless


-------------------------
10/3/21: One month later:
-------------------------
Now in this session I'm going to look at the ES5 React15 version as well as in the more modern
typescript variation of React15.

Ok. so half an hour to gain a better understanding of the terrible ES3/5 React15 module resolution
system. besides the IFEE, the factory function that it accepts, and the entire model that 
describes an array of tuples: each tuple is a React module, and its dependencies which are 
the indexes of other React modules that it depends upon. since I believe it is a terrible
piece of code and would not like to fully dive in it, I will skip it since the important thing is
the mechanism which I feel I understand well, and not the inner details like 
what is e[90][e][s][34] and what module it resolves exactly in each step.
But I will mention that it seems like 90 is the first module that is being resolved, and 90
is the UMD module system resolver, so apperently this React15 variation is UMD-centric

looking at the code, trying to figure out what's going on, still fails and the majority of the
code is unclear to me. I will now try to look at the console logs I generated previously
and see if it helps:

so CreateDOMFactory(tag) is simply binding ReactElement.createElement for this tag.
and so whenever a react component is created, ReactElement.createElement is used to create
the associated html tag to this component.
ReactDOMFactories is a list of ReactElement.createElement functions, for each one of the
html tags.
From the comments: Creates a mapping from supported HTML tags to `ReactDOMComponent` classes

A look at the React application generated code: There is a lot alot of code.
React.createClass is creating a new react component from a blueprint and with the user
given render, getInitialState, etc .. methods. doing a lot of validation on the react component,
and doing ReactElement.createElement, but as soon as
---
ReactDOM.render() is shooting, the entire React engine is going crazy and from 0 to 300 Kps,
with no order, and in a chaotic manner.
it does createElement() for the <Component />
it does ReactMount.render() which is doing _renderSubtreeIntoContainer()
which is doing a lookup for the root element in the container,
then _renderNewRootComponent(), then alot of validations, and wrapper escaping,
then going into ReactUpdates and resolving the UpdatingStrategy chosen.
then Transaction.perform which triggers the system of DOM updates and reconciliation cycles.
which triggers alot of initialization, event initialization as well as other DOM initializations
which constructs ReactReconsileTransaction.
then calling ReactReconciler.mountComponent() asking the React Mounting system to start
working, when doing getReactMountReady(), then calling ReactCompositeComponentMixin.mountComponent()
then calling ReactCompositeComponentMixin.performInitialMount()
and then ReactCompositeComponentMixin._renderValidatedComponent()
then calling ReactDOMComponent.mountComponent()
then doing ReactDOMComponent._updateDOMProperties() even though no update is needed.
then ReactMultiChild.mountChildren() and then ReactChildReconciler.instantiateChildren ()
and traverseAllChildren ()
then ReactDOMComponentTree.getRenderedNativeOrTextFromComponent()
then initializing the React Event system for this application components:
ReactDOMComponent.enqueuePutListener(),
then ReactUpdatesFlushTransaction.flushBatchedUpdate()
---

WOW !!! It is very clear the entire mechanism is sick. I read the order of the things that
happen when ReactDOM.render happens (or ReactMount.render()), but still, it all feels vague to me.
ReactMount._renderNewRootComponent() seems very important in this 'root render install'
which leads to the need to understand batchedMountComponentIntoNode(),
which leads to the need to understand mountComponentIntoNode(),
which leads to the need to understand:
   ReactReconciler.mountComponent(),
   ReactMount._mountImageIntoNode(),
   which leads to:
      internalInstance.mountComponent()
      which leads to:
         markup = this.performInitialMount(
                  renderedElement,
                  nativeParent,
                  nativeContainerInfo,
                  transaction,
                  context
                );
                which leads to:
                ReactReconciler.mountComponent()
                and that's it, I'm lost.



---
PAUSE
---

It seems like I'm stuck. things are too tough to follow, it is very hard to understand React flow,
nature of things. For example, a setState after a button click triggers thousands of function
calls. It is very hard to understand the big picture. Before diving into how specific functions
do what they do and why they do it, I need to see the bigger picture, there I will
make console.func one that gives me more details. another parameter, how important it is, 
the more the function is important, the bigger font it will have. Another parameter should be
a more global one regarding all console logs, when console.mod === 'HIGH-LEVEL', then only
the most important (labeled 10), functions should be console logged.

so let's test this functionality first. What are the most important function calls that are 
happenning when the user clicks a button that setStates ?

ReactEventListener.dispatchEvent
ReactUpdates.ReactUpdatesFlushTransaction.batchedUpdates 
Transaction.perform
ReactEventListener.handleTopLevelImpl
EventPluginHub.extractEvents 
EventPluginHub.getListener
executeDispatchesAndReleaseTopLevel
EventPluginUtils.executeDispatch
ReactComponent.setState
Transaction.perform
ReactCompositeComponentMixin.performUpdateIfNecessary
Calling ReactCompositeComponentMixin.updateComponent 
ReactCompositeComponentMixin._updateRenderedComponent
ReactDOMComponent._updateDOMChildren
shouldUpdateReactComponent  

OK added, it's better, but still, it is not clear enough what's the connection between
function calls. + let's add another level: 1 for the least important function calls.
what are the least important function calls happen when button click triggers setState.
- it is also very helpful if in each function calls, besides the general description, 
  there will also be an ascii sketch of the flow of actions done within this function.
  for example: 
  ReactEventListener.dispatchEvent:
  TopLevelCallbackBookKeeping.getPooled ---> ReactUpdates.batchedUpdates ---> TopLevelCallbackBookKeeping.release

Yeah, so the last additions to the logger are great, but I'm missing details, like a third kind
of description (besides console.desc, console.sketch):

---

so in general I have no clue of whats going on inside React BatchedUpdates mechanisms,
will come back to it some other time.

Now, let's think of another layer of logging that will make things clearer:
- anytime the DOM is changed, use a big font and show the change ? a special kind of 
log with moving cool border effect !

---

let's take a simple DOM actualy changing, when button click triggers setState that changes
the state of age from 0 to 10, then eventually the dom node will be updated:
node.textContent = 10, but the console.trace looks like that:

setTextContent (setting the node.textContent)
replaceDelimitedText
   (doing something with comment nodes and calling setTextContent)
   in this case, openingComment is <!-- react-text: 4 -->
   closingComment is <!-- /react-text -->
   and the stringText is 10
   and so replaceDelimitedText will create an actual dom text node from 10
   by calling createTextNode, or putting the 10 somewhere else.

DOMChildrenOperations_replaceDelimitedText 
receiveComponent 
ReactDOMTextComponent_receiveComponent 
receiveComponent 
updateChildren 
_reconcilerUpdateChildren 
_updateChildren 
updateChildren 
_updateDOMChildren 
updateComponent 
receiveComponent 
ReactDOMComponent_receiveComponent 
receiveComponent 
updateChildren 
_reconcilerUpdateChildren 
_updateChildren 
updateChildren 
_updateDOMChildren 
updateComponent 
receiveComponent 
ReactDOMComponent_receiveComponent 
receiveComponent 
_updateRenderedComponent 
_performComponentUpdate 
updateComponent 
ReactCompositeComponent_updateComponent 
performUpdateIfNecessary 
performUpdateIfNecessary 
runBatchedUpdates 
perform 
perform 
perform 
flushBatchedUpdates 
ReactUpdates_flushBatchedUpdates 
closeAll 
perform 
batchedUpdates 
batchedUpdates (calling transaction.perform)
dispatchEvent (after the click event happens, the React Event System begins working)

which can be sum up shortly:
dispatchEvent -> transaction.perform -> _updateRenderedComponent -> _reconcilerUpdateChildren -> updateChildren -> receiveComponent -> setTextContent

thoughts: ReactDOMTextComponent with all the 'comment node' logic is a terrible piece of 
engineering, 

still. no idea how React works.. no idea... let's keep on reading the source code .

---

ReactEvent.dispatchEvent:
1:
transaction.perform(handleTopLevelImpl)
2:
EventPluginHub.extractEvents
3:
EventPluginHub.getListener 
4:
ReactEventEmitterMixin.runEventQueueInBatch
5:
EventPluginUtils.executeDispatch
6:
ReactComponent.setState
7:
ReactCompositeComponentMixin.updateComponent
8:
ReactCompositeComponentMixin._updateRenderedComponent
9:
Calling shouldUpdateReactComponent
10:
Calling setTextContent (ACTUAL DOM CHANGING!!!)


NOTE: from module 92 up to the last module 167 - those are utils I understand well...
tomorrow: start from module 146 and above 

thoughts: traverseAllChildrenImpl() is the most unclear function from this entire codebase

reading through the Transaction module code, it seems like the most important module
in React v15. (FULLY UNDERSTOOD)

reading through the SyntheticEvent module, 

--
so I read from module 167 up to 92. Now I will read from 1 forwards.
after that ? I will try again to follow the actions triggered by
a simple button click with setState,

--
CallbackQueue is the next module I am about to read (yes again).
yeah, very simple module. simple a list of callbacks, contexts with enqueue option, reset option,
and notifyall to iterate on the callbacks and calling them with the contexts.
except that it also has pooling added to. (for avoiding garbage collection exaushting)
--
ChangeEventPlugin.runEventInBatch is the next method I'm investigating:
--
one last look at sequence of actions triggered by a button click that setStates
still.. not clear to me... tomorrow we will try yet another way of deep diving React v15.

actually something nice I found now:
DOMProperty.DOMPropertyInjection.injectDOMPropertyConfig:

react-15.js:138  ---> [ Description: Inject some specialized knowledge about the DOM. 
This takes a config object with the following properties: 
react-15.js:2235 domPropertyConfig: 
      DOMAttributeNames:
      acceptCharset: "accept-charset"
      className: "class"
      htmlFor: "for"
      httpEquiv: "http-equiv"
      __proto__: Object
      DOMPropertyNames: {}
      Properties: {accept: 0, acceptCharset: 0, accessKey: 0, action: 0, allowFullScreen: 4, …}
      isCustomAttribute: ƒ ()
      __proto__: Object
which tells the story on how React made 'class' a 'className' and 'htmlFor' 'for'
which is actually defined in module 22: HTMLDOMPropertyConfig.

next to deep dive: the object pooling mechanism in React:
---------

reading react 15 source code from beginning to end, again. thoughts:
- much clearer than before
- ReactUpdates.batchedUpdates(runEventInBatch, event) in manualDispatchChangeEvent is not clear.
  The entire philosophy behind ReactUpdates.batchedUpdates is not clear in this context
--------------
Ok, so eventually I didn't understand React v15 after all.. (after all this source code readings)
I hope at least I got a better grasp (though a very vague one) how it works behind the scenes.
--------------
I will now (from tomorrow) start reading React v17 source code. 
