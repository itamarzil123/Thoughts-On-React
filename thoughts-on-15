React-15: (vs previous versions v0.14, v0.3)
--------------------------------


ABOUT REACT IN GENERAL:
What is React ? it's a javascript abstraction of the DOM. it adds layers to the native event system
native markup, native DOM API, therefore creating a unified interface and a change detection mechanism
between the native DOM and your javascript world. 

React wrapps the native Event system with its own Event system called React Event System with actors
like 'EventPlugins', 'SynthenticEvent' etc . . doing event normalization across browsers and environments
and also making the native event system easy to deal with inside React internal API.

it's smallest building block is a component. A React application is nothing but a tree of functions
that communicate through state and props. each of these functions has its own representation of the DOM,
it's own UI, and so it's called a React Component because it is not only a function that receives props,state
and communicate with props state, but it is also a UI unit. 

Reacy component lifecycle includes being born as a function (constructor), being mounted, being updated, and
eventually being unmounted from the DOM. React public API reveals some lifecycle methods for the React user.

The most popular usage of React is using JSX which is a transformer from <Componet props/> syntax to 
component(props) syntax.

React 'change detection mechanism' and constant reconciliation (dom update) process is based on checking if 
the markup of a component is different than the real DOM markup after any change in props, state
which is related to the component.

React patterns, or 'opinion' is to be immutable and change state only in immutable manners.

--------------------------
React v15 vs v0.3, 0.14:
--------------------------
from the official changeLog:
         document.createElement is in and data-reactid is out
         No more extra <span>s
         React.cloneElement() now resolves defaultProps
         Function components can now return null too

         Deprecated APIs are removed from the React top-level export:
         findDOMNode, render, renderToString, renderToStaticMarkup, and unmountComponentAtNode.
         As a reminder, they are now available on ReactDOM and ReactDOMServer.
         Deprecated addons are removed: batchedUpdates and cloneWithProps.
         Deprecated component instance methods are removed: setProps, replaceProps, and getDOMNode.
         React-specific properties on DOM refs (e.g. this.refs.div.props) were deprecated,
         and are removed now
my observations:

1. $$typeof: Symbol(react.element) is now holding the id of a React component

2. data-reactroot is used (as opposed to ReactRootId[] in v0.3, v0.14)


3. the updater in a React component in v15 has the following fields:
      enqueueCallback: ƒ (publicInstance, callback, callerName)
      enqueueCallbackInternal: ƒ (internalInstance, callback)
      enqueueElementInternal: ƒ (internalInstance, newElement)
      enqueueForceUpdate: ƒ (publicInstance)
      enqueueReplaceState: ƒ (publicInstance, completeState)
      enqueueSetState: ƒ (publicInstance, partialState)
      isMounted: ƒ (publicInstance)
      validateCallback: ƒ (callback, callerName)
      __proto__: Object

4. all the AccumulateDispatch methods survived v15 (existed from v0.3)

0. this.updater inside ReactClass is the same as in v0.14. this.updater is the object inside ReactClass
   which stores methods like enqueueSetState and replaceState

1. module system resolver: recognize the module system used by the React user.
   commonJS? AMD? otherwise just put React on the global object
2. sub modules resolver function that manages the entire inner 'require' of internals modules inside
   the React library. it is very ugly and bad designed.. it is a good decision by the React team to abandon
   this attitude.
3. until line 700, I see no interesting/important code to research, but only React internal Event system
   meaningless names

4. in line 900, CallbackQueue is defined (with Pooledclass) just like ReactOnDOMReady in version 0.3, 0.14
   this module is responsible for handling callbacks like componentDidMount/DidUpdate to run after component's
   markup has been injected to the DOM. the queue itself is a list of React components ready to be notified
   after their DOM has been injected. callbackQueue holds _callbacks and _contexts. and for example
   notifyAll will call each callback with the matching context. (callback.call(context))
5. reading through lines 1200+ it seems like React overall suffers from tightling coupling of different units
   such as the React Event system and the DOM utils and the React API (or namings), etc  . . .
   the way React is written is not modular. the way the reader reads the code is very not clear,
   too much complexity, and too much chaos. not clear which are the basic units and which are the bigger/higher
   units of engineering.
6. module 28: React policies still exist apparently (as in v0.3 and v.14) except for additions:
   DEFINE_MANY_MERGED,
   ReactClassInterface I believe is the new ReactCompositeComponentInterface
   bindAutoBindMethod also still exists.

7. ReactClass is a the module to create composite components in v15

8. shouldUpdateReactComponent: in v15 React offers its own implementations while in previous versions
   it only relied on the user's shouldUpdateReactComponent

NOTES:
    key code snippets:
    ReactDOMComponentTree.getNodeFromInstance,
    ReactDOMComponentTree.getClosestInstanceFromNode,
    DOMLazyTree,
    createNodesFromMarkup,
    dangerouslyRenderMarkup,
    EventPropagators,
    EventPluginRegistry,
    EventPluginUtils,
    ReactEventEmitterMixin,
    ReactEventListener,
    ReactChildren,
    ReactComponent,
    ReactClass,
    ReactElement,
    createElement,
    ReactReconciler,
    ReactInstrumentation




          /**
           * Internal store for event listeners
           */
          var listenerBank = {};

          /**
           * Internal queue of events that have accumulated their dispatches and are
           * waiting to have their dispatches executed.
           */
          var eventQueue = null;
                    /**
           * - `ComponentTree`: [required] Module that can convert between React instances
           *   and actual node references.
           */
           /**
           * Standard/simple iteration through an event's collected dispatches.
           */
          function executeDispatchesInOrder




NOTES: even in versions 0.14, 0.3, and in 15, still it all feels like a magic.
How exactly React works internally ?









NOTES:
    The DOM CompositionEvent represents events that occur due to the user indirectly entering text.









TESTS:
----------
    1
----------
a simple <button onClick={() => console.log('click')}></button>
yields the following sequence of method invocations:
 1. before any event click is triggered, when React launches, trapBubbledEvent() is called
    and it is putting 'click' event listener on document
    and dispatchEvent is the handler for this click event
    When React sees 'onClick' on a virtual DOM element, its EventPluginHub is putting a listener on the 
    element. 

2. the user clicks on the Hello World button and trigger the following sequence:

  ---> Calling dispatchEvent (because the click event, before all, belongs to the document tartet,
                              and dispatchEvent is the listener for this target)
  ---> Calling batchedUpdates
  ---> Calling perform 
  ---> Calling initializeAll 
  ---> Calling getEventTarget -> SEE EXPLANATIONS BENEATH
 nativeEvent: MouseEvent {isTrusted: true, screenX: 1986, screenY: 83, clientX: 66, clientY: 11, …}
  ---> Calling getEventTarget 
 nativeEvent: MouseEvent {isTrusted: true, screenX: 1986, screenY: 83, clientX: 66, clientY: 11, …}
  ---> Calling ReactEventEmitterMixin.handleTopLevel 
  ---> Calling EventPluginHub.extractEvents 
  ---> Calling SimpleEventPlugin.extractEvents 
  ---> Calling SyntheticEvent 
  ---> Calling listenerAtPhase 
  ---> Calling EventPluginHub.getListener 
  ---> Calling listenerAtPhase 
  ---> Calling EventPluginHub.getListener 
  ---> Calling EnterLeaveEventPlugin.extractEvents 
  ---> Calling ChangeEventPlugin.extractEvents 
  ---> Calling SelectEventPlugin.extractEvents 
  ---> Calling BeforeInputEventPlugin.extractEvents 
  ---> Calling extractCompositionEvent 
  ---> Calling EventPluginHub.enqueueEvents 
  ---> Calling EventPluginHub.processEventQueue 
  ---> Calling executeDispatchesInOrder 
  ---> Calling executeDispatch 
 event: Proxy {dispatchConfig: {…}, _targetInst: ReactDOMComponent, isDefaultPrevented: ƒ, isPropagationStopped: ƒ, _dispatchListeners: ƒ, …}
clicked

summary:
   1.getEventTarget = indentifying which native event was fired
   1.1 handleTopLevel = identifying the native event as 'topClick'
   2.extractEvents = the appropriate EventPluginHub which is SimpleEventPlugin is 
     'extracting' the native 'click' event, which is basically building a new object from native event
     this new object is the React Event that has the native event as one of its fields as well as
     some extra fields, logic\data. React Event is called SyntheticEvent,
     in this case: SynthecticMouseEvent
   3. EventPluginHub.getListener = identifying which React Component is the target of the event fire
   4. calling 'extractEvents' of all other plugins in the DefaultEventPlugin list (in order)
      ---> Calling EnterLeaveEventPlugin.extractEvents 
      ---> Calling ChangeEventPlugin.extractEvents 
      ---> Calling SelectEventPlugin.extractEvents 
      ---> Calling BeforeInputEventPlugin.extractEvents
   5. EventPluginHub.enqueueEvents
   6. EventPluginHub.processEventQueue
   7. ExecuteDispatchesInOrder = executes all the components onClick handlers (they are the event listeners)
      dispatchListeners is the onClick handlers, and dispatchInstances are the component themselves.
   8. executeDispatch -> in this case () => console.log('click')


SO: 
onclick -> onClick -> EventPlugin -> SimpleEventPlugi -> wrapping onclick with ReactSyntheticEvent -> fire events and triggering listeners 

   NOTE: as we can see transaction.perform which triggers initializeAll and closeAll, happens not only
         whenever the component state is updated and there is a reconciliation of the React DOM to the real DOM
         (and then the callbacks such as componentDidMount, DidUpdate are called once the component is DOM injected)
         but a transaction.perform is called after every event fired.


----------
    2
----------
React.createClass({ render: function() { return <button onClick={() => console.log('click');> </button> }})

what this code is causing React to do ?
1. user calls: React.createClass(spec)
2. ReactClass.createClass(spec) which does:
         bindAutoBindMethods(),
         getInitialState(),
         new ReactClassComponent(),
         mixSpecIntoComponent(Constructor, spec);
         and retuning an object that looks like that:
            Constructor {props: undefined, context: undefined, refs: {…}, updater: {…}, state: null}
               context: undefined
               props: undefined
               refs:
               __proto__: Object
               state: null
               updater:
               enqueueCallback: ƒ (publicInstance, callback)
               enqueueForceUpdate: ƒ (publicInstance)
               enqueueReplaceState: ƒ (publicInstance, completeState)
               enqueueSetState: ƒ (publicInstance, partialState)
               isMounted: ƒ (publicInstance)
               __proto__: Object
               __proto__: ReactClassComponent
               childContextTypes: null
               componentDidMount: null
               componentDidUpdate: null
               componentWillMount: null
               componentWillReceiveProps: null
               componentWillUnmount: null
               componentWillUpdate: null
               constructor: ƒ (props, context, updater)
               contextTypes: null
               getChildContext: null
               getDefaultProps: null
               getInitialState: null
               mixins: null
               propTypes: null
               render: ƒ ()
               shouldComponentUpdate: null
               statics: null
               updateComponent: null
               __reactAutoBindPairs: []
               __proto__: Object
3. NOTE: new Button() is different than new Component().
   apparently React.CreateElement patches it with: 
   $$typeof: Symbol(react.element) as well as hiding this.updater from it
   Apparently <Button /> is going through some phases like React.createElement which further manipulates it:
      ---> Calling ReactElementValidator.getDeclarationErrorAddendum 
      ---> Calling ReactElement.createElement 
      ---> Calling ReactElementValidator.validatePropTypes 
4.
---> Calling ReactClass.mixSpecIntoComponent 
---> Calling ReactElement.isValidElement 
---> Calling ReactClass.validateMethodOverride 
---> Calling ReactClass.RESERVED_SPEC_KEYS.displayName 
---> Calling ReactClass.validateMethodOverride


NOTES:
   React.createClass() is a terrible API, not only for the outsider( aka the React user), but internally 
   from within the React project, it is a terrible API.